
#' Restore a Virtual Environment
#'
#' Restore a virtual environment from a manifest, as previously generated by
#' [snapshot()].
#'
#' @param manifest The manifest to be used for restoration of the associated
#'   virtual environment. When `NULL`, the most recently-generated manifest
#'   for this project is used.
#'
#' @inheritParams renv-params
#'
#' @family reproducibility
#'
#' @export
restore <- function(manifest = NULL, confirm = interactive()) {

  # resolve the manifest
  manifest <- case(
    is.null(manifest)      ~ renv_manifest_load(),
    is.character(manifest) ~ renv_manifest_read(manifest),
    manifest
  )

  # check to see if the virtual environment used to generate
  # this manifest already exists -- if not, create it
  name <- manifest$Environment$Environment
  envir <- renv_paths_environment(name)
  if (!file.exists(envir)) {

    # remove state-related entries from the manifest
    blueprint <- manifest
    blueprint$R$Package <- NULL

    # write the blueprint
    ensure_parent_directory(envir)
    renv_manifest_write(blueprint, file = envir)

  }

  # detect changes in R packages in the manifest
  old <- snapshot(name, file = NULL)
  new <- manifest
  actions <- renv_manifest_diff_packages(old, new)

  # detect missing dependencies -- e.g. if an installed package depends on
  # one or more packages that are no longer available
  if (!length(actions)) {
    fmt <- "%s envirnoment '%s' is up to date."
    messagef(fmt, if (renv_state$local()) "Local virtual" else "Virtual", name)
    return(invisible(actions))
  }

  if (confirm || renv_verbose())
    renv_restore_report_actions(actions, old, new)

  if (confirm && !proceed()) {
    message("Operation aborted.")
    return(invisible(actions))
  }

  # perform the restore
  status <- renv_restore_run_actions(actions, old, new)

  # check to see if the manifest is now up-to-date; if it's not,
  # then the restore might've repaired the dependency tree and
  # this should now be snapshotted
  after <- snapshot(name, file = NULL)
  if (!identical(after, new)) {

    msg <- lines(
      "",
      "The dependency tree was repaired during package restoration.",
      "You will be prompted to snapshot the newly-installed packages."
    )

    writeLines(msg)
    snapshot(name)

  }

  invisible(status)
}

renv_restore_run_actions <- function(actions, old, new) {

  renv_restore_begin(new, names(actions))
  on.exit(renv_restore_end(), add = TRUE)

  enumerate(actions, function(package, action) {
    if (action %in% c("install", "upgrade", "downgrade", "crossgrade"))
      renv_restore_install(package, new)
    else if (action %in% c("remove"))
      renv_restore_remove(package, old)
    else
      warningf("Unrecognized action '%s' for package '%s'", action, package)
  })

}

renv_restore_install <- function(package, manifest = NULL) {

  # skip 'R' package that might be passed in here
  if (package == "R")
    return(TRUE)

  # skip 'base' packages
  base <- renv_installed_packages_base()
  if (identical(base[package, "Priority"], "base"))
      return(TRUE)

  # if we've already attempted installation of this package, skip
  state <- renv_restore_state()
  if (exists(package, envir = state$visited))
    return(TRUE)

  # mark package as installing
  state$visited[[package]] <- TRUE

  # extract manifest if none provided
  manifest <- manifest %||% state$manifest

  # extract the package record (attempt to construct one if missing)
  record <- manifest$R$Package[[package]]

  # if we have a package record (ie: this package is already installed), but
  # the user did not explicitly request installation of this package, then we
  # can just skip
  if (!is.null(record) && !package %in% state$packages)
    return(TRUE)

  # if we don't have a package record, try to infer one for installation
  if (is.null(record)) {

    # if this package is already installed, nothing to do
    # TODO: but normally, packages have a notion of which library they were
    # installed in... how do we recover this information? can we make an
    # educated guess somehow?
    libpaths <- renv_libpaths_all()
    packages <- list.files(libpaths)
    if (package %in% packages)
      return(TRUE)

    # otherwise, infer a record and install it
    record <- renv_restore_install_missing_record(package)

  }

  # check for an entry in the cache we can use
  cache <- renv_cache_package_path(record)
  if (file.exists(cache)) {
    status <- renv_restore_install_package_cache(record, cache)
    if (identical(status, TRUE))
      return(TRUE)
  }

  # otherwise, try and restore from external source
  # TODO: what to assume if no source provided? just use CRAN?
  source <- tolower(record[["Source"]] %||% "CRAN")
  switch(source,
    cran         = renv_restore_install_cran(record),
    bioconductor = renv_restore_install_bioconductor(record),
    github       = renv_restore_install_github(record),
    bitbucket    = renv_restore_install_bitbucket(record),
    renv_restore_install_unknown_source(record)
  )

}

renv_restore_install_missing_record <- function(package) {

  # TODO: allow users to configure the action to take here, e.g.
  #
  #   1. install latest from CRAN (the default),
  #   2. request a package + version to be installed,
  #   3. hard error
  #

  entry <- NULL
  for (type in c("binary", "source")) {
    entry <- catch(renv_available_packages_entry(package, type))
    if (is.data.frame(entry))
      break
  }

  if (!is.data.frame(entry)) {
    fmt <- "Failed to install package '%s' (missing record and failed to discover on CRAN)"
    stopf(fmt, package)
  }

  # TODO: explicit API for constructing a package record
  # TODO: infer correct source for package
  list(
    Package = package,
    Version = entry$Version,
    Library = NULL,
    Source  = "CRAN"
  )

}

renv_restore_install_bioconductor <- function(record) {
  # TODO
}

renv_restore_install_github <- function(record) {

  if (requireNamespace("remotes", quietly = TRUE))
    return(renv_restore_install_github_remotes(record))

  fmt <- "https://%s/repos/%s/%s/tarball/%s"

  url <- with(record, sprintf(fmt, RemoteHost, RemoteUsername, RemoteRepo, RemoteSha))
  path <- renv_paths_source(record$Package, record$RemoteSha)

  renv_restore_install_package(record, url, path, "source")

}

renv_restore_install_github_remotes <- function(record) {

  fmt <- "Installing %s [%s] from %s ..."
  with(record, messagef(fmt, Package, Version, renv_alias(Source)))
  status <- catch(
    remotes::install_github(
      repo = file.path(record$RemoteUsername, record$RemoteRepo),
      ref = record$RemoteRef,
      host = record$RemoteHost,
      upgrade = FALSE,
      quiet = TRUE
    )
  )

  renv_restore_install_report_status(record, status, "source")

}

renv_restore_install_bitbucket <- function(record) {
  # TODO
}

renv_restore_install_cran <- function(record) {

  # always attempt to install from source + archive
  methods <- c(
    renv_restore_install_cran_source,
    renv_restore_install_cran_archive
  )

  # only attempt to install binaries when explicitly requested by user
  # TODO: what about binaries on Linux?
  if (!identical(getOption("pkgType"), "source"))
    methods <- c(renv_restore_install_cran_binary, methods)

  for (method in methods) {
    status <- method(record)
    if (inherits(status, "error"))
      stop(status)

    if (identical(status, TRUE))
      return(TRUE)
  }

  stopf("Failed to restore package '%s' from CRAN", record$Package)

}

renv_restore_install_cran_binary <- function(record) {

  sysname <- Sys.info()[["sysname"]]
  suffix <- switch(sysname, Darwin = "tgz", Windows = "zip", "tar.gz")
  name <- sprintf("%s_%s.%s", record$Package, record$Version, suffix)
  renv_restore_install_cran_impl(record, "binary", name)

}

renv_restore_install_cran_source <- function(record) {

  name <- sprintf("%s_%s.tar.gz", record$Package, record$Version)
  renv_restore_install_cran_impl(record, "source", name)

}

renv_restore_install_cran_archive <- function(record) {

  name <- sprintf("%s_%s.tar.gz", record$Package, record$Version)
  for (repo in getOption("repos")) {
    repo <- file.path(repo, "src/contrib/Archive")
    if (renv_restore_install_cran_impl(record, "source", name, repo))
      return(TRUE)
  }

  return(FALSE)

}

renv_restore_install_cran_impl <- function(record, type, name, repo = NULL) {

  entry <- renv_restore_install_cran_entry(record, type, repo)
  if (empty(entry))
    return(FALSE)

  # TODO: allow version mismatches? (e.g. restore latest instead of requested)reco
  if (!identical(entry$Version, record$Version))
    return(FALSE)

  url <- file.path(entry$Repository, name)
  path <- case(
    type == "binary" ~ renv_paths_binary(record$Package, name),
    type == "source" ~ renv_paths_source(record$Package, name)
  )

  renv_restore_install_package(record, url, path, type)

}


renv_restore_install_cran_entry <- function(record, type, repo = NULL) {

  # if a repository was explicitly supplied, use it (this is the case
  # when e.g. installing a package from the archive; repo is used so
  # that we form a link to the appropriate spot in the CRAN archive)
  if (!is.null(repo))
    return(c(record, Repository = repo))

  # otherwise, get the associated entry from CRAN's available packages
  renv_available_packages_entry(record$Package, type) %||% list()

}

renv_restore_install_package <- function(record, url, path, type) {

  # download the package
  # TODO: toggle path based on whether package cache is enabled?
  if (!file.exists(path)) {
    ensure_parent_directory(path)
    status <- catch(download(url, destfile = path))
    if (inherits(status, "error") || identical(status, FALSE))
      return(status)
  }

  # ensure its dependencies are installed first
  deps <- renv_dependencies_discover_description(path)
  for (package in deps$Package)
    renv_restore_install(package)

  # install the package now
  fmt <- "Installing %s [%s] from %s ..."
  with(record, messagef(fmt, Package, Version, renv_alias(Source)))

  status <- tryCatch(
    renv_restore_install_package_local(record, path, type = type),
    condition = identity
  )

  renv_restore_install_report_status(record, status, type)

}

renv_restore_install_package_cache <- function(record, cache) {

  # ensure dependencies are installed first
  deps <- renv_dependencies_discover_description(cache)
  for (package in deps$Package)
    renv_restore_install(package)

  # now do the restore
  renv_restore_install_package_cache_impl(record, cache)

}

renv_restore_install_package_cache_impl <- function(record, cache) {

  # construct target install path
  library <- case(
    is.null(record$Library)       ~ renv_libpaths_default(),
    path_absolute(record$Library) ~ record$Library,
    TRUE                          ~ renv_paths_library(record$Library)
  )
  target <- file.path(library, record$Package)

  # determine if we should copy or link from the cache
  # (prefer copying if we're writing to a non-renv path)
  link <- if (path_within(target, renv_paths_library()))
    renv_file_link
  else
    renv_file_copy

  # back up the previous installation if needed
  callback <- renv_file_scoped_backup(target)
  on.exit(callback(), add = TRUE)

  # now, try to hydrate from cache
  status <- catch(link(cache, target))
  if (!identical(status, TRUE))
    return(status)

  # report successful link to user
  fmt <- "Installing %s [%s] ..."
  with(record, messagef(fmt, Package, Version))

  type <- case(
    identical(link, renv_file_copy) ~ "copied",
    identical(link, renv_file_link) ~ "linked"
  )

  messagef("\tOK (%s cache)", type)

  return(TRUE)
}

renv_restore_install_package_local <- function(record, path, type) {

  package <- record$Package
  library <- if (!is.null(record$Library))
    renv_paths_library(record$Library)

  # get user-defined options to apply during installation
  options <- renv_restore_install_package_options(package)

  # run user-defined hooks before, after install
  before <- options$before.install %||% identity
  after  <- options$after.install %||% identity

  before(package)
  on.exit(after(package), add = TRUE)

  install.packages(

    pkgs  = path,
    lib   = library %||% renv_libpaths_default(),
    repos = NULL,
    type  = type,
    quiet = TRUE,

    configure.args = options$configure.args,
    configure.vars = options$configure.vars,
    INSTALL_opts   = options$install.options

  )

}

renv_restore_remove <- function(package, manifest) {
  record <- manifest$R$Package[[package]]
  messagef("Removing %s [%s] ...", package, record$Version)
  remove.packages(package, renv_paths_library(record$Library) %||% NULL)
  message("\tOK (removed from library)")
  TRUE
}

renv_restore_state <- function() {
  renv_global_get("restore.state")
}

renv_restore_begin <- function(manifest = NULL, packages = NULL) {
  envir <- new.env(parent = emptyenv())
  envir$manifest <- manifest
  envir$packages <- packages
  envir$visited <- new.env(parent = emptyenv())
  renv_global_set("restore.state", envir)
}

renv_restore_end <- function() {
  renv_global_clear("restore.state")
}

renv_restore_report_actions <- function(actions, old, new) {

  if ("install" %in% actions) {
    msg <- "The following package(s) will be installed:"
    renv_pretty_print(msg, new, actions, "install")
  }

  if ("remove" %in% actions) {
    msg <- "The following package(s) will be removed:"
    renv_pretty_print(msg, old, actions, "remove")
  }

  if ("upgrade" %in% actions) {
    msg <- "The following package(s) will be upgraded:"
    renv_pretty_print_pair(msg, old, new, actions, "upgrade")
  }

  if ("downgrade" %in% actions) {
    msg <- "The following package(s) will be downgraded:"
    renv_pretty_print_pair(msg, old, new, actions, "downgrade")
  }

  if ("crossgrade" %in% actions) {
    msg <- "The following package(s) will be modified:"
    renv_pretty_print_pair(msg, old, new, actions, "crossgrade")
  }

}

renv_restore_install_package_options <- function(package) {
  options <- getOption("renv.install.package.options")
  options[[package]]
}

renv_restore_install_unknown_source <- function(record) {
  fmt <- "Can't restore package '%s': '%s' is an unrecognized source."
  stopf(fmt, record$Package, record$Source, call. = FALSE)
}

renv_restore_install_report_status <- function(record, status, type) {

  if (inherits(status, "error")) {
    message("\tFAILED")
    return(status)
  }

  feedback <- case(
    type == "source" ~ "built from source",
    type == "binary" ~ "installed binary"
  )

  messagef("\tOK (%s)", feedback)
  renv_cache_synchronize(record)

  return(TRUE)

}

