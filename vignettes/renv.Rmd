---
title: "Introduction to renv"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to renv}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>",
  eval     = FALSE
)
```

The `renv` package provides project-local R dependency management to your projects.
This means that instead of having a single library containing the packages that you use for every project, you have a separate library for each project.
This means that different projects can use different versions of packages, keeping the dependencies of each project isolated so that upgrading the packages in one project, doesn't affect your other projects.

This vignette assumes that you're are already living a project centric lifestyle and are familiar with a version control system like Git and GitHub; we believe these are table stakes for reproducible data science.
If you're not already using projects, we recommend starting by reading [Workflow: Projects](https://r4ds.had.co.nz/workflow-projects.html) from *R for Data Science*; if you're unfamiliar with [Git](https://git-scm.com/) and [GitHub](https://github.com/), we recommend [Happy Git and GitHub for useR](https://happygitwithr.com).

## Getting started

To convert a project to use `renv`, call `renv::init()`.
This scans your R code to discover what packages you are currently using[^1], records the packages and their versions in a **lockfile**, `renv.lock`, and creates a project-specific library, `renv/library`, containing the installed packages[^2]
. It also creates a project `.Rprofile` which will automatically load `renv` when you use this project again in the future
. This immediately gives you the benefit of **isolation**: now when you install, update, or remove packages, it only affects this project, not every project on your computer
.

[^1]: See `?dependencies` for the details and how to customise.

[^2]: If you'd like to skip the dependency discovery you can call `renv::init(bare = TRUE)` to initialize a project with an empty project library.

The next important `renv` tool is `renv::snapshot()`.
This updates the lockfile with the currently installed package versions, and means that other people on other computers can easily reproduce your current environment by running `renv::restore()`.
This pair of functions give you the benefits of **reproducibility** and **portability**: you are now tracking exactly which package versions you have installed, and can recreate them on other machines.

These three functions form the heart of `renv`'s most important workflows, but there are other important functions like `renv::status()`, `renv::install()`, `renv::update()`, and `renv::remove()` that we'll learn more about below.

### Collaboration

One of the reasons that you might be interested in `renv` is that you want to share your code with other people and have them get the same results as you because they're using the same versions of the packages that you have installed.

As above, you'll start by calling `renv::init()`.
You'll then need to commit the correct files to a version control system.
If you're using git, this is particularly simple because `renv` will create a `.gitignore` for you, and you can just commit the suggested files: `renv.lock`, `.Rprofile`, `renv/settings.json` and `renv/activate.R`[^3].

[^3]: If you're using another version control system, you'll need to ignore `renv/library`.

Now when one of your collaborators opens this project, `renv` will automatically bootstrap itself, downloading and installing the appropriate version of `renv`.
It will not, however, install the packages automatically --- you'll need to tell your collaborators to call `renv::restore()` to get all the packages they need.

### Installing new packages

Over time, your project will need more packages.
One of the philosophies of `renv` is that your existing package management workflows should continue to work, can you can continue to use `install.packages()`.
But you can also use `renv::install()`, which is a little less typing and supports installing and updating packages from GitHub, Bioconductor, and more, not just CRAN.

After installing the package and checking that your code still works, call `renv::snapshot()` to record the latest versions in your lockfile.
If you're collaborating with others, you'll need to commit those changes to git, and let them know that you've update the lockfile.

If you're unsure how your library and lockfile differ, call `renv::status()`.

### Package updates

It's worth noting that there's a small risk associated with isolation: while you\'re no longer vulnerable to breakages, but you also don\'t benefit from fixes.
So for packages under active development, we recommend that you regularly (at least once a year) use `renv::update()`[^4] to get the latest version of all packages.
Similarly, if you pick up a project that you haven\'t worked on for a while, we think it's a good idea to start with an `renv::update()` before making any changes to the code.

[^4]: You can also use `update.packages()`, but `renv::update()` also works for packages installed from Bioconductor, GitHub, and Git.

After calling `renv::update()`, you should run the code in your project and make sure it works.
Then call `renv::snapshot()`, to make sure the versions of the new dependencies are included in the lockfile.
If you get stuck, and can't get the project to work with the new versions, you can always call `renv::restore()` to revert to the last known good state.
If you need to roll back to an even older version, take a look at `renv::history()` and `renv::revert()`.

`renv::update()` will also update `renv` itself.
See `renv::upgrade()` if you ever want to upgrade just `renv`, or you need to install a development version from GitHub.

### Caveats

It is important to emphasize that `renv` is not a panacea for reproducibility.
Rather, it is a tool that can help make projects reproducible by solving one small part of the problem: R packages.
Ultimately, making a project reproducible will always require thought, not just mechanical usage of a tool: what does it mean for a particular project to be reproducible, and how can you use tools to meet that particular goal of reproducibility?

In particular, the results produced by a particular project might depend on other components of the system it's being run on, e.g. the operating system itself, the versions of system libraries in use, the compilers used to build R and R packages, and so on.
Keeping a 'stable' machine image is a separate challenge, but [Docker](https://www.docker.com/) is one popular solution.
See also `vignette("docker", package = "renv")` for recommendations on how Docker can be used together with `renv`.

A salient example of this is the `rmarkdown` package, as it relies heavily on [`pandoc`](https://pandoc.org/).
However, because pandoc is not bundled with the `rmarkdown` package simply restoring an `renv` project using `rmarkdown` may not be sufficient: you also needs to ensure the project is run in a environment with the correct version of `pandoc` available.

You also need to be aware that package installation may fail if a package was originally installed through a binary, but that binary is no longer available.
`renv` will attempt to install the package from source, but this can (and often will) fail due to missing system prerequisites.
`renv::equip()` can provide some help here, particularly on Windows, because it will download external software commonly used when compiling R packages from sources.

## Infrastructure

Now that you've got the basics usage of renv under your belt, it's time to learn a bit more about the underlying infrastructure.
You typically won't touch any of these files directly, but it's good to understand what they do because you will see them in git diffs.

`renv::init()` creates the following important files and directories:

-   `.Rprofile:` Used to activate `renv` for new R sessions launched in the project by calling `source("renv/activate.R")`.
-   `renv/activate.R`: The activation script run by the project `.Rprofile`. This ensures that the project library is made active for newly launched R sessions. This ensures that any new R processes launched within the project directory will use the project library, and hence are isolated from the regular user library.
-   `renv.lock`: The lockfile, describing the state of your project's library at some point in time.
-   `renv/library`: The private project library.
-   `renv/settings.json`: Project settings -- see `?settings` for more details.

For development and collaboration, `renv/library` directory should be ignored and all others checked in.
`renv::init()` will help by automatically writing requisite ignore statements to the project `.gitignore`.

### Anatomy of a lockfile

Of these files, `renv.lock` is most important, and will change the most over the life of a project, so it's good to know exactly what's going on.
A lockfile is json file that records all the information need to recreate your package in the future.
It includes:

-   The version of `R` used.
-   Your R repositories.
-   **Package records** defining each R package, their version, and their installation source.

Here is an example lockfile, including the packages `markdown` and `mime`:

```         
{
  "R": {
    "Version": "`r getRversion()`",
    "Repositories": [
      {
        "Name": "CRAN",
        "URL": "https://cloud.r-project.org"
      }
    ]
  },
  "Packages": {
    "markdown": {
      "Package": "markdown",
      "Version": "1.0",
      "Source": "Repository",
      "Repository": "CRAN",
      "Hash": "4584a57f565dd7987d59dda3a02cfb41"
    },
    "mime": {
      "Package": "mime",
      "Version": "0.7",
      "Source": "Repository",
      "Repository": "CRAN",
      "Hash": "908d95ccbfd1dd274073ef07a7c93934"
    }
  }
}
```

### Package records

The package records are created using the currently-installed copies of packages as a "source of truth".
The fields written into each package record are derived from the installed package's `DESCRIPTION` file, and include the data required to recreate installation, regardless of whether the package was installed from [CRAN](https://cran.r-project.org/), [Bioconductor](https://www.bioconductor.org/), [GitHub](https://github.com/), [Gitlab](https://about.gitlab.com/), [Bitbucket](https://bitbucket.org/), or elsewhere.
You can learn more about what souces renv supports in `vignette("package-sources")`.

Note that the package records created from packages installed using `pak::pkg_install()` may have a format different from a package installed with `utils::install.packages()`.
This is because `pak` writes out a variety of other metadata into the package `DESCRIPTION` file after installation, including a number of `Remote` fields that further describe where the package was retrieved from, and the type of package that was installed.

## Uninstalling renv

If you find `renv` isn't the right fit for your project, deactivating and uninstalling it is easy.

-   To deactivate `renv` in a project, use `renv::deactivate()`.
    This removes the `renv` auto-loader from the project `.Rprofile`, but doesn't touch any other `renv` files used in the project.
    If you'd like to later re-activate `renv`, you can do so with `renv::activate()`.

-   To remove `renv` from a project, first call `renv::deactivate()` then delete the `renv/` folder and `renv.lock` lockfile.

If you want to completely remove any installed `renv` infrastructure components from your entire system, you can do so with the following R code:

```         
root <- renv::paths$root()
unlink(root, recursive = TRUE)
```

The `renv` package can then also be uninstalled via:

```         
utils::remove.packages("renv")
```

Note that if you've customized any of `renv`'s infrastructure paths as described in `?renv::paths`, then you'll need to find and remove those customized folders as well.

## Packrat

`renv` is our second attempt at solving this problem, using what we learned from [packrat](https://rstudio.github.io/packrat/) to create a system with fewer surprises and better default behaviors.

### Differences

`renv` differs from Packrat in the following ways:

1.  The `renv` lockfile `renv.lock` is formatted as [JSON](https://www.json.org/).
    This should make the lockfile easier to use and consume with other tools.

2.  `renv` no longer attempts to explicitly download and track R package source tarballs within your project.
    This was a frustrating default that operated under the assumption that you might later want to be able to restore a project's private library without access to a CRAN repository.
    In practice, this is almost never the case, and the time spent downloading + storing the package sources seemed to outweigh the potential reproducibility benefits.

3.  Packrat tried to maintain the distinction between so-called 'stale' packages; that is, R packages which were installed by Packrat but were not recorded in the lockfile for some reason.
    This distinction was (1) overall not useful, and (2) confusing.
    `renv` no longer makes this distinction: `snapshot()` saves the state of your project library to `renv.lock`, `restore()` loads the state of your project library from `renv.lock`, and that's all.

4.  In `renv`, the global package cache is enabled by default.
    This should reduce overall disk-space usage as packages can effectively be shared across each project using `renv`.

5.  `renv`'s dependency discovery machinery is more configurable.
    The function `renv::dependencies()` is exported, and users can create `.renvignore` files to instruct `renv` to ignore specific files and folders in their projects.
    (See `?renv::dependencies` for more information.)

### Migrating from Packrat

The `renv::migrate()` function makes it possible to migrate projects from Packrat to `renv`.
See the `?migrate` documentation for more details.
In essence, calling `renv::migrate("<project path>")` will be enough to migrate the Packrat library and lockfile such that they can then be used by `renv`.
